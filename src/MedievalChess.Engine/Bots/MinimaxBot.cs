using System;
using System.Collections.Generic;
using System.Linq;
using MedievalChess.Domain.Aggregates;
using MedievalChess.Domain.Entities;
using MedievalChess.Domain.Enums;
using MedievalChess.Domain.Primitives;
using MedievalChess.Engine.Evaluation;
using MedievalChess.Engine.Logic;
using MedievalChess.Engine.Structures;

namespace MedievalChess.Engine.Bots
{
    public class MinimaxBot : IMedievalEngine
    {
        private const int MaxDepth = 3; // Start with Depth 3
        private readonly int _depth;

        public MinimaxBot(int depth = MaxDepth)
        {
            _depth = depth;
        }

        public Move CalculateBestMove(Game game, int timeLimitMs)
        {
            // 1. Convert to Engine State
            var mapping = BoardMapper.Map(game);
            var rootState = mapping.State;
            var pieceMap = mapping.PieceMap;

            EngineMove bestMove = default;
            int bestScore = int.MinValue;
            
            // Generate Root Moves
            var moves = new List<EngineMove>(50);
            EngineMoveGenerator.GenerateMoves(ref rootState, moves);
            
            // Provide a fallback if no moves (Stalemate/Checkmate should have been handled by Game)
            if (moves.Count == 0) throw new Exception("No legal moves generated by Engine");

            // Alpha-Beta Search
            int alpha = int.MinValue + 1;
            int beta = int.MaxValue - 1;

            foreach (var move in moves)
            {
                var nextState = ApplyMove(rootState, move);
                int score = -AlphaBeta(nextState, _depth - 1, -beta, -alpha);

                if (score > bestScore)
                {
                    bestScore = score;
                    bestMove = move;
                }
                
                if (score > alpha) alpha = score;
            }

            // Map back to Domain Move
            var piece = pieceMap[bestMove.FromIndex];
            var newPos = new Position(bestMove.ToSquare % 8, bestMove.ToSquare / 8);
            
            // We need to resolve the TARGET piece from Domain Board based on 'bestMove.ToSquare'
            // Because our PieceMap is just index->piece, but the capture logic in Domain expects the specific reference
            var targetPiece = game.Board.GetPieceAt(newPos); // Should match TargetIndex logic

            var domainMove = new Move(piece.Position!.Value, newPos, piece, targetPiece);
            
            if (piece.Type == PieceType.Pawn && MedievalChess.Domain.Entities.Pieces.Pawn.IsPromotionRank(newPos.Rank, piece.Color))
            {
                domainMove.PromotionPiece = PieceType.Queen; // Always promote to Queen for now in simplified engine
            }

            return domainMove;
        }

        private int AlphaBeta(EngineGameState state, int depth, int alpha, int beta)
        {
            if (depth == 0)
            {
                // In quiescence search we would continue for captures, but for now fixed depth
                return MedievalEvaluator.Evaluate(state, state.CurrentTurn);
            }

            var moves = new List<EngineMove>(50);
            EngineMoveGenerator.GenerateMoves(ref state, moves);

            if (moves.Count == 0)
            {
                // Terminal Node check: King captured?
                // Actually if no moves, it's Stalemate or Checkmate
                // We'd need IsCheck logic. 
                // For simplified engine: Return Evaluation (likely negative if losing)
                return MedievalEvaluator.Evaluate(state, state.CurrentTurn); 
            }
            
            // Move Ordering: Captures first
            // Simple heuristic swap
            for(int i=0; i<moves.Count; i++)
            {
                 if(moves[i].IsCapture)
                 {
                     // Swap to front-ish or just process first? 
                     // Just simple separate lists or generic sort
                 }
            }
            // For now, rely on generator order (which processes things sequentially)

            foreach (var move in moves)
            {
                var nextState = ApplyMove(state, move);
                
                // King Capture Safety Check prune?
                // If I just let my king be captured, Score should be -Infinity.
                
                int score = -AlphaBeta(nextState, depth - 1, -beta, -alpha);

                if (score >= beta) return beta; // Cutoff
                if (score > alpha) alpha = score;
            }

            return alpha;
        }

        private EngineGameState ApplyMove(EngineGameState original, EngineMove move)
        {
            var next = original.Clone();
            
            // Move Piece
            ref var piece = ref next.Pieces[move.FromIndex];
            
            // Clear old square
            next.BoardSquares[piece.SquareIndex] = 255;
            ulong oldBit = 1UL << piece.SquareIndex;
            if (piece.Color == 0) next.WhiteOcc &= ~oldBit; else next.BlackOcc &= ~oldBit;

            // Handle Capture / Combat
            if (move.IsCapture)
            {
                byte victimIdx = move.TargetIndex; 
                ref var victim = ref next.Pieces[victimIdx];

                if (next.IsAttritionMode)
                {
                    // Calculate expected damage based on type
                    int baseDamage = piece.Type switch
                    {
                        0 => 60,  // Pawn
                        1 => 120, // Knight
                        2 => 100, // Bishop
                        3 => 150, // Rook
                        4 => 200, // Queen
                        5 => 80,  // King
                        _ => 50
                    };

                    int damageAfterArmor = Math.Max(0, baseDamage - victim.Armor);
                    
                    // Note: We don't simulate RNG for crits or glancing blows in the Minimax search 
                    // to keep the branching factor and node evaluation deterministic and fast.

                    victim.CurrentHP -= (short)damageAfterArmor;

                    if (victim.CurrentHP <= 0)
                    {
                        // Victim is dead
                        victim.IsCaptured = true;
                        victim.SquareIndex = 255;
                        
                        ulong victimBit = 1UL << move.ToSquare;
                        if (victim.Color == 0) next.WhiteOcc &= ~victimBit; else next.BlackOcc &= ~victimBit;
                        
                        // Attacker moves into square
                        piece.SquareIndex = move.ToSquare;
                        piece.HasMoved = true;
                        next.BoardSquares[move.ToSquare] = move.FromIndex;
                        
                        ulong newBit = 1UL << move.ToSquare;
                        if (piece.Color == 0) next.WhiteOcc |= newBit; else next.BlackOcc |= newBit;
                    }
                    else
                    {
                        // Attack Bounce: Defender survives, attacker stays in original square
                        // Restore attacker to old square
                        next.BoardSquares[piece.SquareIndex] = move.FromIndex;
                        ulong oldBitRestored = 1UL << piece.SquareIndex;
                        if (piece.Color == 0) next.WhiteOcc |= oldBitRestored; else next.BlackOcc |= oldBitRestored;
                        
                        piece.HasMoved = true; // Still counts as an action
                    }
                }
                else
                {
                    // Standard Chess 1-Hit Kill
                    victim.IsCaptured = true;
                    victim.SquareIndex = 255;
                    
                    ulong victimBit = 1UL << move.ToSquare;
                    if (victim.Color == 0) next.WhiteOcc &= ~victimBit; else next.BlackOcc &= ~victimBit;

                    // Place on new square
                    piece.SquareIndex = move.ToSquare;
                    piece.HasMoved = true;
                    next.BoardSquares[move.ToSquare] = move.FromIndex;
                    
                    ulong newBit = 1UL << move.ToSquare;
                    if (piece.Color == 0) next.WhiteOcc |= newBit; else next.BlackOcc |= newBit;
                }
            }
            else
            {
                // Normal Move
                piece.SquareIndex = move.ToSquare;
                piece.HasMoved = true;
                next.BoardSquares[move.ToSquare] = move.FromIndex;
                
                ulong newBit = 1UL << move.ToSquare;
                if (piece.Color == 0) next.WhiteOcc |= newBit; else next.BlackOcc |= newBit;
            }
            
            // Switch Turn
            next.CurrentTurn = next.CurrentTurn == PlayerColor.White ? PlayerColor.Black : PlayerColor.White;
            if (next.CurrentTurn == PlayerColor.White) next.TurnNumber++;

            return next;
        }

        public bool IsMoveValid(Game game, Move move)
        {
            // Fallback to strict validation via lightweight generator or domain service?
            // Interface implementation not critical for search itself.
            return true; 
        }
    }
}
