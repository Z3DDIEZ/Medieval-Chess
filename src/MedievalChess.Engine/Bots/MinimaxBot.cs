using System;
using System.Collections.Generic;
using System.Linq;
using MedievalChess.Domain.Aggregates;
using MedievalChess.Domain.Entities;
using MedievalChess.Domain.Enums;
using MedievalChess.Domain.Primitives;
using MedievalChess.Engine.Evaluation;
using MedievalChess.Engine.Logic;
using MedievalChess.Engine.Structures;

namespace MedievalChess.Engine.Bots
{
    public class MinimaxBot : IMedievalEngine
    {
        private const int MaxDepth = 3; // Start with Depth 3
        private readonly int _depth;

        public MinimaxBot(int depth = MaxDepth)
        {
            _depth = depth;
        }

        public Move CalculateBestMove(Game game, int timeLimitMs)
        {
            // 1. Convert to Engine State
            var mapping = BoardMapper.Map(game);
            var rootState = mapping.State;
            var pieceMap = mapping.PieceMap;

            EngineMove bestMove = default;
            int bestScore = int.MinValue;
            
            // Generate Root Moves
            var moves = new List<EngineMove>(50);
            EngineMoveGenerator.GenerateMoves(ref rootState, moves);
            
            // Provide a fallback if no moves (Stalemate/Checkmate should have been handled by Game)
            if (moves.Count == 0) throw new Exception("No legal moves generated by Engine");

            // Alpha-Beta Search
            int alpha = int.MinValue + 1;
            int beta = int.MaxValue - 1;

            foreach (var move in moves)
            {
                var nextState = ApplyMove(rootState, move);
                int score = -AlphaBeta(nextState, _depth - 1, -beta, -alpha);

                if (score > bestScore)
                {
                    bestScore = score;
                    bestMove = move;
                }
                
                if (score > alpha) alpha = score;
            }

            // Map back to Domain Move
            var piece = pieceMap[bestMove.FromIndex];
            var newPos = new Position(bestMove.ToSquare % 8, bestMove.ToSquare / 8);
            
            // We need to resolve the TARGET piece from Domain Board based on 'bestMove.ToSquare'
            // Because our PieceMap is just index->piece, but the capture logic in Domain expects the specific reference
            var targetPiece = game.Board.GetPieceAt(newPos); // Should match TargetIndex logic

            var domainMove = new Move(piece.Position!.Value, newPos, piece, targetPiece);
            
            if (piece.Type == PieceType.Pawn && MedievalChess.Domain.Entities.Pieces.Pawn.IsPromotionRank(newPos.Rank, piece.Color))
            {
                domainMove.PromotionPiece = PieceType.Queen; // Always promote to Queen for now in simplified engine
            }

            return domainMove;
        }

        private int AlphaBeta(EngineGameState state, int depth, int alpha, int beta)
        {
            if (depth == 0)
            {
                // In quiescence search we would continue for captures, but for now fixed depth
                return MedievalEvaluator.Evaluate(state, state.CurrentTurn);
            }

            var moves = new List<EngineMove>(50);
            EngineMoveGenerator.GenerateMoves(ref state, moves);

            if (moves.Count == 0)
            {
                // Terminal Node check: King captured?
                // Actually if no moves, it's Stalemate or Checkmate
                // We'd need IsCheck logic. 
                // For simplified engine: Return Evaluation (likely negative if losing)
                return MedievalEvaluator.Evaluate(state, state.CurrentTurn); 
            }
            
            // Move Ordering: Captures first
            // Simple heuristic swap
            for(int i=0; i<moves.Count; i++)
            {
                 if(moves[i].IsCapture)
                 {
                     // Swap to front-ish or just process first? 
                     // Just simple separate lists or generic sort
                 }
            }
            // For now, rely on generator order (which processes things sequentially)

            foreach (var move in moves)
            {
                var nextState = ApplyMove(state, move);
                
                // King Capture Safety Check prune?
                // If I just let my king be captured, Score should be -Infinity.
                
                int score = -AlphaBeta(nextState, depth - 1, -beta, -alpha);

                if (score >= beta) return beta; // Cutoff
                if (score > alpha) alpha = score;
            }

            return alpha;
        }

        private EngineGameState ApplyMove(EngineGameState original, EngineMove move)
        {
            var next = original.Clone();
            
            // Move Piece
            ref var piece = ref next.Pieces[move.FromIndex];
            
            // Clear old square
            next.BoardSquares[piece.SquareIndex] = 255;
            ulong oldBit = 1UL << piece.SquareIndex;
            if (piece.Color == 0) next.WhiteOcc &= ~oldBit; else next.BlackOcc &= ~oldBit;

            // Handle Capture
            if (move.IsCapture)
            {
                // The victim is at move.ToSquare
                byte victimIdx = move.TargetIndex; 
                // Safety: Verify victimIdx matches board?
                // Trust generator.
                
                ref var victim = ref next.Pieces[victimIdx];
                victim.IsCaptured = true;
                victim.SquareIndex = 255;
                
                // Remove victim bit
                ulong victimBit = 1UL << move.ToSquare;
                if (victim.Color == 0) next.WhiteOcc &= ~victimBit; else next.BlackOcc &= ~victimBit;
            }

            // Place on new square
            piece.SquareIndex = move.ToSquare;
            piece.HasMoved = true;
            next.BoardSquares[move.ToSquare] = move.FromIndex;
            
            ulong newBit = 1UL << move.ToSquare;
            if (piece.Color == 0) next.WhiteOcc |= newBit; else next.BlackOcc |= newBit;
            
            // Switch Turn
            next.CurrentTurn = next.CurrentTurn == PlayerColor.White ? PlayerColor.Black : PlayerColor.White;
            if (next.CurrentTurn == PlayerColor.White) next.TurnNumber++;

            return next;
        }

        public bool IsMoveValid(Game game, Move move)
        {
            // Fallback to strict validation via lightweight generator or domain service?
            // Interface implementation not critical for search itself.
            return true; 
        }
    }
}
